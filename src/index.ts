import type { VKey } from 'snarkjs'
import { curves, groth16 } from 'snarkjs'

import { extractPublicInputsFromCircuitInputs, snarkJSToStandardProof, standardToSnarkJSInput, standardToSnarkJSProof, standardToSnarkJSPublicInputs } from './formatter'
import type { CircuitInputs, Proof, ProverArtifacts, PublicInputs } from './types'

/**
 * Create a zero-knowledge proof for a Railgun transaction
 *
 * Generate a cryptographic proof that can be used to validate a Railgun transaction,
 * (transfers of tokens/NFTs) without revealing sensitive details about the sender, receiver, or amounts.
 * The proof can be verified on-chain to confirm the transaction's validity.
 *
 * @param circuitInputs - Transaction details including input/output UTXOs, merkle paths, and nullifiers
 * @param artifacts - Circuit artifacts, for ex. 1x2_zkey, 1x2.wasm, 1x2.vkey.json
 * @returns Object containing the standardized proof and public inputs needed for verification
 */
async function prove (circuitInputs: CircuitInputs, artifacts: ProverArtifacts): Promise<{ proof: Proof, publicInputs: PublicInputs }> {
  // Format the inputs into snarkJS format
  const snarkJSFormattedInputs = standardToSnarkJSInput(circuitInputs)

  // Generate proof
  const { proof } = await groth16.fullProve(snarkJSFormattedInputs, artifacts.wasm, artifacts.zkey)

  // Standardize the proof
  const standardProof = snarkJSToStandardProof(proof)

  // Extract public inputs
  const snarkJSFormattedPublicInputs = extractPublicInputsFromCircuitInputs(circuitInputs, standardProof)

  // Create snarkJS proof
  const snarkJSFormattedProof = standardToSnarkJSProof(standardProof)

  // Ensure proof passes verification
  // NOTE: snarkJS can generate a proof for invalid inputs, so we must verify it before sending to the contract
  groth16.verify(artifacts.vkey, snarkJSFormattedPublicInputs, snarkJSFormattedProof)

  // Format to Uint8Array and return
  return { proof: standardProof, publicInputs: snarkJSFormattedPublicInputs }
}

/**
 * Verify a zero-knowledge Railgun transaction proof
 *
 * Validate that a cryptographic proof represents a legitimate Railgun transaction
 * without needing to reveal the private transaction details. It checks that the transaction
 * satisfies all the cryptographic constraints defined by the circuit.
 *
 * @param publicInputs - Public data extracted from the transaction (commitment hashes, nullifiers, etc.)
 * @param proof - The ZK-SNARK proof generated by the prove() function
 * @param vkey - Verification key specific to the circuit type used (e.g., 1x2, 2x3)
 * @returns true if the proof is valid, false otherwise
 */
function verify (publicInputs: PublicInputs, proof: Proof, vkey: VKey): Promise<boolean> {
  // Convert standard proof to snarkJS format
  const snarkJSFormattedProof = standardToSnarkJSProof(proof)
  const snarkJSFormattedPublicInputs = standardToSnarkJSPublicInputs(publicInputs)

  // Verify the proof and return result
  return groth16.verify(vkey, snarkJSFormattedPublicInputs, snarkJSFormattedProof)
}

/**
 * Cleanup snarkJS resources
 * @returns Promise<void>
 *
 * https://github.com/iden3/snarkjs/issues/152
 * https://github.com/iden3/snarkjs/issues/393
 */
async function cleanupSnarkJS (): Promise<void> {
  // Initialize the curve object controlling wasm threads
  const curve = await curves.getCurveFromName('bn128')

  // Terminate threads
  curve.terminate()
}

export type { CircuitInputs, ProverArtifacts, Proof, PublicInputs } from './types'
export { prove, verify, cleanupSnarkJS } 